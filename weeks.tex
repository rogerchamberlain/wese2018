\section{Modules}
\label{sec:weeks}

As described above, each module is comprised of a pre-quiz, studio, an assignment, and a post-quiz.  The class starts a new module each non-exam week, completing it the following week. There are minor schedule adjustments around the exam, but students generally have one calendar week to complete each module's assignment. Also, the first laboratory meeting (labeled studio 0) is used to familiarize the students with various logistics, such as the development environment (both Eclipse~\cite{eclipse} and Arduino IDE~\cite{arduino}), the code repository, etc. The available modules (both in use currently and developed in previous semesters but not currently in use) are described below.

\emph{Information Representation} (Module A) --
The intellectual content for this module is centered around understanding how information is represented in digital systems. This includes binary and hexadecimal conversions, integer number representations (including 2's complement), as well as ASCII and UTF text.  Students are also introduced to the finite-state machine abstraction, and how to implement a finite-state machine in software. All of the above concepts are reinforced multiple times over the course of the semester, mastery is expected by the end of the semester.

\emph{Microcontroller Platform} (Module B) --
The content for this module includes how to physically implement electricalmcircuits, a brief introduction to electricity (a physics course is not a prerequisite) and voltage, digital inputs and outputs, and finite-state machine design.

\emph{Real-Time Computing} (Module C) --
This module's content includes techniques for including time as a functional element in software. Starting with delay-based timing (calling a routine that blocks and returns after a specified time), they progress to delta timing (checking each loop to determine if the desired time has elapsed), at which point they have a complete soft real-time system.  This is combined with analog inputs (including the conversion of raw A/D  input values into engineering units) and simple filtering (averaging), utilizing a temperature probe.

\emph{Communications} (Modules D,E) (2 weeks) --
This pair of modules investigates the issues inherent in using a byte stream to communicate between two dissimilar computer systems (the Arduino using Cand the desktop PC using Java).  Students explore how to serialize multi-byte data types, design protocols that enable synchronization in the face of dropped bytes (e.g., using a magic number as a message header), and design finite-state machine recognizers to parse incoming messages. An illustrative example is the exploration of strings on the two execution platforms and in the messaging protocol (one-byte vs.~two-byte characters, null termination vs. character count).

\emph{Multiplexing} (Module F) --
This module introduces the concept of time-division multiplexing, asking the students to interface to and author the software to drive a 5 by 7 pixel LED display. Real-time computing concepts are reinforced, and students are introduced to the fundamental mechanisms involved in larger, more sophisticated, pixed-based displays (e.g., font design, time multiplexing).

\emph{Integrative Project} (Module G) --
In this module the students design and implement an integrative project that seeks to reinforce concepts that have been introduced earlier in the semester.  A second analog sensor is made available (an accelerometer) for the project.  Different projects have been used in different semesters, including the development of a pedometer (mimicking a health monitor when paired with the temerature sensor) and a predator-prey game (that uses the accelerometer to sense the tilt of the microcontroller, one of the two game player's input mechanisms).

\emph{Computer Architecture / Assembly Language} (Modules H,I,J) (3 weeks) --
This three week set of modules has an introduction to basic computer architecture (what is a fetch-execute engine) and machine language, and then focuses on assembly language, using the simple, 8-bit AVR instruction set. The first week concentrates on data representation (especially multi-byte data), data movement, and data manipulation (e.g., how to perform 16-bit addition by using two 8-bit add instructions, understanding the need for a carry bit). The second week introduces more general forms of program control, for example, the assembly language techniques for implementing if-then-else logic and loop structures. The third week incorporates memory more substantially, covering pointers and array access. At the end of these three modules, students are not expected to be sophisticated assembly language programmers by any means.  The motivation is primarily to ensure the computer science students have been exposed, and the computer engineering students are better prepared for the deeper coverage that comes later (e.g., in their computer architecture course).

The relationship between intellectual topics and individual modules is shown in Table~\ref{tbl:topics}. The columns in the table represent modules, and the rows represent topics.  There is some overlap between topic names and module labels; however, that typically implies that the specific topic is central to the module of the same name, that that it is the only topic present in the module.

\begin{table}[ht]
\caption{Relationship between intellectual topics and modules.}
\label{tbl:topics}
\centering
\begin{tabular}{l | c | c | c | c | c | c | c}
Topic $\Downarrow$ \ \ \ Module $\Rightarrow$ & A & B & C & D,E & F & G & H,I,J \\ \hline
Information & $\blacksquare$ & $\blacksquare$ & $\blacksquare$ & $\blacksquare$ & & $\blacksquare$ & $\blacksquare$ \\
    Representation (\textsection\ref{sec:ip}) & & & & & & &\\ \hline
FSMs (\textsection\ref{sec:fsm}) & $\blacksquare$ & $\blacksquare$ & & $\blacksquare$ & & & \\ \hline
Timing \& Evenys (\textsection\ref{sec:time}) & & $\blacksquare$ & $\blacksquare$ & & $\blacksquare$ & $\blacksquare$ & \\ \hline
Physical I/O (\textsection\ref{sec:pio}) & & $\blacksquare$ & $\blacksquare$ & $\blacksquare$ & $\blacksquare$ & $\blacksquare$ &  $\blacksquare$ \\ \hline

Communications (\textsection\ref{sec:comm}) & & & & $\blacksquare$ & & $\blacksquare$ & \\ \hline
Architecture / & & & & & & & $\blacksquare$ \\
    Assembly Lang. (\textsection\ref{sec:arch}) & & & & & & & \\
\end{tabular}
\centerline{\mbox{\ }}
\centerline{{\Large Time $\longrightarrow$}}
\centerline{\mbox{\ }}
\centerline{Module Legend}
\centering
\begin{tabular}{c | l }
Module & Name \\ \hline
A & Information Representation \\
B & Microcontroller Platform \\
C & Real-Time Computing \\
D,E & Communications \\
F & Multiplexing \\
G & Integrative Project \\
H,I,J & Computer Arch. / Assembly Lang.
\end{tabular}
\end{table}

In addition to the modules described above, there are a few modules that have been developed and used in previous semesters, but are not in current use.

\emph{Interrupts} --
Students explore how interrupts literally interrupt any currently executing tasks.  In addition, students see how interrupts improve responsivenes to events, like button presses (which can further excerbate bouncing).

\emph{IP Networking} --
This module introduces the students to topics in networking.  IP protocols, including both TCP/IP and UDP/IP are covered, as well as domain name service and socket-based communications. The assignment includes an HTTP request to a remote server (using the desktop PC) and displaying a symbolic version of the response on the Arduino pixel display.
