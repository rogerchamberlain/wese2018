\section{Modules}
\label{sec:weeks}

As described above, each module is comprised of a pre-quiz, studio,
an assignment, and a post-quiz.  The class starts a new module each
non-exam week, completing it the following week. There are minor schedule
adjustments around the exam, but students generally have one calendar week
to complete each module's assignment.
Also, the first laboratory meeting (labeled studio 0) is used to familiarize
the students with various logistics, such as the development environment
(both Eclipse~\cite{eclipse} and Arduino IDE~\cite{arduino}),
the code repository, etc.
The available modules
(both in use currently and developed in previous semesters but not
currently in use) are described below.

\emph{Information Representation} --
The intellectual content for this module is centered around understanding
how information is represented in digital systems. This includes binary and
hexadecimal conversions, integer
number representations (including 2's complement), as well as
ASCII and UTF text.
Students are also introduced to the finite-state machine abstraction,
and how to implement a finite-state machine in software.
All of the above concepts are reinforced multiple times over the course
of the semester, mastery is definitely not expected with only one week
of exposure.

\emph{Microcontroller Platform} --
The content for this module includes how to physically implement electrical
circuits, a brief introduction to electricity (a physics course is not a
prerequisite) and voltage, digital inputs and outputs, and finite-state
machine design.

\emph{Real-Time Computing} --
This module's content includes techniques for including time as a functional
element in software. Starting with delay-based timing (calling a routine
that blocks and returns after a specified time), they progress to delta
timing (checking each loop to determine if the desired time has elapsed),
at which point they have a complete soft real-time system.
This is combined with analog inputs (including the conversion of raw A/D
input values into engineering units) and simple filtering (averaging).

\emph{Computer Communications} (2 weeks) --
This pair of modules investigates the issues inherent in using a byte stream
to communicate between two dissimilar computer systems (the Arduino using C
and the desktop PC using Java).  Students explore how
to serialize multi-byte data types, design protocols that enable synchronization
in the face of dropped bytes (e.g., using a magic number as a message header),
and design finite-state machine recognizers to parse incoming messages.
An illustrative example is the exploration of strings on the two execution
platforms and in the messaging protocol (one-byte vs.~two-byte characters,
null termination vs. character count).

\emph{Multiplexing} -- Pixel-based displays.

\emph{Integrative Project} -- Acceleration. Pedometer. Predator-prey game.

\emph{Computer Architecture / Assembly Language} (3 weeks) -- Data layout.
Program control. Arrays in memory.

In addition to the modules described above, there are a few modules that
have been developed and used in previous semesters, but are not in current use.

\emph{Interrupts} --
\FIXME{describe}.

\emph{IP Networking} --
This module introduces the students to topics in networking.  IP protocols,
including both TCP/IP and UDP/IP are covered, as well as domain name service
and socket-based communications. The assignment includes an HTTP request
to a remote server (using the desktop PC) and displaying a symbolic version
of the response on the Arduino pixel display.
